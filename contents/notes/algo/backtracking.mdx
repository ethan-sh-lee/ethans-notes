---
id: 1
title : 'Backtracking(백트래킹) 완전정복'
description: '대표적인 알고리즘인 백트래킹 알고리즘의 이해와 문제풀이에 적용해보기'
publishedAt: '2024-06-01 12:00:00'
isPublished: false
---

# 백트래킹 알고리즘이란
**Backtracking(백트래킹 or 퇴각검색)** 은 다양한 옵션을 점진적으로 시도 하고
 막다른 골목에 이르면 해당 옵션을 취소한 후
 이전 상태로 돌아간 후 다른 옵션으 다시 시도하는 문제 해결 알고리즘입니다.


## DFS vs Backtracking vs Dynamic Programming 
**DFS는** 트리나 그래프의 깊은 부분을 우선으로 탐색하는 알고리즘이다. 
주로 모든 노드를 순회할 때 사용한다.

DFS를 기반으로 백트래킹과 DP를 구현할 수 있습니다.

**백트래킹은** 제약조건을 만족하지 못하거나 더이상 탐색할 후보가 없으면 이전 단계로 거슬러 올라갑니다.
 DFS와는 달리 모든 경로를 탐색하지 않고 조기에 종료할 수 있어 효율적입니다.
 그래프 노드에서 분기 계수 b와 지름 h가 있는 경우, 노드를 방문하는 각 단계에서 모든 인접 이웃 노드를 저장하면 메모리 요구량은 big-O(bh)가 됩니다.
 그러나 한번에 하나의 이웃 노드만 가져와서 확장하면 메모리 복잡성이 big-O(h)로 줄어듭니다. 전자는 DFS이고 후자는 백트래킹입니다.
 주로 문제에 대해 제약조건을 위반하지 않는 모든 솔루션을 얻기 위해 사용됩니다.

**다이나믹 프로그래밍은** DFS에 메모이제이션 기법을 사용하는 알고리즘입니다. 이미 계산된 값을 다음 계산에 사용하여 다시 계산하는 것을
피할 수 있습니다. DP는 여러가지 솔루션을 찾지 않고 최대값과 같은 하나의 최적의 해를 구하는 알고리즘입니다.

## 수도코드

``` 
function FIND_SOLUTIONS(parameters):
    if(valid solution)
        ACCEPT(solution)
        return
    
    for (choice : choices):
        if(valid choice):   
            ACCEPT(choice) 
            FIND_SOLUTIONS(parameters): 
            BACKTRACK(remove choice)
```

## 연습문제
### 1. [78. Subsets](https://leetcode.com/problems/subsets/description/)

고유한 정수 집합에서 모든 부분집합을 구해야 한다. 결과의 순서는 상관없다.

Input: nums = [1,2,3]

Output: [[], [1], [2], [1,2], [3], [1,3], [2,3], [1,2,3]]
#### 상태공간 트리
``` mermaid

graph TB
    A((empty))--1번-->B((1))
    B--2번-->C((1, 2))
    C--7번-->B
    C--3번-->D((1, 2, 3))
    D--4번-->DD((End)):::endclass
    DD--5번-->D
    D--6번-->C
    B--8번-->E((1, 3))
    E--9번-->EE((End)):::endclass
    EE--10번-->E
    E--11번-->B
    B--12번-->A
    A--13번-->F((2))
    F--14번-->G((2, 3))
    G--15번-->GG((End)):::endclass
    GG--16번-->G
    G--17번-->F
    F--18번-->A
    A--19번-->H((3))
    H--20번-->HH((End)):::endclass
    HH--21번-->H
    H--22번-->A
    classDef endclass fill:#f6546a
```
백트래킹은 깊이 우선 탐색을 사용하기 때문에 화살표에 적힌 순서대로 탐색을 한다.

1, 2, 3 이후 더이상 탐색할 후보가 없기 때문에 함수가 종료되고 이전 함수로 돌아간다.

이전 노드에서도 이미 3번을 탐색하였기 때문에 백트래킹하고 함수가 종료된다.

한번 더 이전 노드에서는 2번만 탐색하였기 때문에 3번을 탐색한다. 3번 이후 탐색할 후보가 없기 때문에 함수가 종료된다.

이것을 반복하여 모든 솔루션을 찾는다.

#### 코드
``` java 
class Solution {
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> list = new ArrayList<>();
        Arrays.sort(nums);
        dfs(list, new ArrayList<>(), nums, 0);
        return list;
    }

    private void dfs(List<List<Integer>> list, List<Integer> path, int[] nums, int start) {
        list.add(new ArrayList<>(path));
        for (int i = start; i < nums.length; i++) { 
            path.add(nums[i]); 
            dfs(list, path, nums, i + 1);
            path.remove(path.size() - 1);
        }
    }
}
```
for문을 통해 nums를 모두 반복하여 가능한 모든 후보를 탐색합니다. 제약조건이 없기 때문에 모든 부분 솔루션이 곧 솔루션이 됩니다.
재귀함수를 통해 더 깊게 탐색을 시도합니다. 이때 이미 탐색한 후보의 다음 후보부터 탐색하기 위해 i + 1을 넘겨줍니다. 
for문을 실행할 수 없는, 즉 후보가 없는 경우 함수가 종료됩니다.

path는 현재 함수의 솔루션을 추적하는데 사용합니다. path에 값이 추가되면 솔루션 또는 부분 솔루션이 되며 이후에 유효성 검사를 통해 결과값에 추가됩니다.
path 마지막에 추가된 값이 삭제되면 솔루션을 추가하기 이전 상태로 되돌아갑니다. 이것이 백트래킹의 주요 구현입니다.

path는 기술적으로 하나의 레퍼런스를 모든 재귀함수에서 사용하기 때문에 static 변수로 생각하면 편합니다.

### 2. [90. Subsets II](https://leetcode.com/problems/subsets-ii/description/)
위 subsets 문제에서 인풋인 정수배열에 중복 숫자가 허용된 문제입니다.

아웃풋 집합에서 중복된 부분 집합은 포함하지 않아야 합니다.

Input: nums = [1,2,2]

Output: [[ ], [1], [1,2], [1,2,2], [2], [2,2]]

#### 상태공간 트리 
``` mermaid

graph TB
    A((empty))-->B((1))
    B-->C((1, 2))
    C-->D((1, 2, 2))
    B-->E((1, 2)):::endclass
    A-->F((2))
    F-->G((2, 2))
    A-->H((2)):::endclass
    classDef endclass fill:#f6546a
```
subset과 같은 방식으로 문제를 풀게되면 위와같이 중복된 집합이 포함된 솔루션을 반환하게 됩니다.

Output: [[ ], [1], [1,2], [1,2,2], [1, 2], [2], [2,2], [2]]

중복을 제거하기 위해서 다음 후보를 가져올 때 이전 후보와 같은지를 확인해야합니다.

nums[i]를 확인했더니 2인 경우 num[i - 1]도 2였다면 더 이상 진행하면 안됩니다.

nums[i - 1]이 배열의 범위를 벗어나는 것을 방지하기 위해 i > start를 추가해줍니다.

```java {2}
for (int i = start; i < nums.length; i++) {
    if (i > start && nums[i] == nums[i - 1]) continue;
    path.add(nums[i]);
    dfs(list, path, nums, i + 1);
    path.remove(path.size() - 1);
}
```
또한 매번 이전 값만 비교하기 때문에 올바르게 작동하기 위해 인풋 배열을 정렬해야만 합니다.

```java {3}
public List<List<Integer>> subsetsWithDup(int[] nums) {
    List<List<Integer>> list = new ArrayList<>();
    Arrays.sort(nums);
    dfs(list, new ArrayList<>(), nums, 0);
    return list;
    }
```

#### 전체코드

``` java 
class Solution {
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        List<List<Integer>> list = new ArrayList<>();
        Arrays.sort(nums);
        dfs(list, new ArrayList<>(), nums, 0);
        return list;
    }

    private void dfs(List<List<Integer>> list, List<Integer> path, int[] nums, int start) {
        list.add(new ArrayList<>(path));
        for (int i = start; i < nums.length; i++) {
            if (i > start && nums[i] == nums[i - 1]) continue;
            path.add(nums[i]);
            dfs(list, path, nums, i + 1);
            path.remove(path.size() - 1);

        }
    }
}
```

### 3. [46. Permutations](https://leetcode.com/problems/permutations/description/)
정수배열이 주어지면 가능한 모든 순열을 반환한다.

Input: nums = [1,2,3]

Output: [[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]]

#### 상태공간 트리
``` mermaid
graph TB
    A((empty))-->B((1))
    B-->C((1, 2))
    C-->D((1, 2, 3)):::solution
    B-->E((1, 3)) 
    E-->F((1, 3, 2)):::solution
    A-->G((2))
    G-->H((2, 1))
    H-->I((2, 1, 3)):::solution
    G-->J((2, 3))
    J-->K((2, 3, 1)):::solution
    A-->L((3))
    L-->M((3, 1))
    M-->N((3, 1, 2)):::solution
    L-->O((3, 2))
    O-->P((3, 2, 1)):::solution

    classDef solution fill:#d3ffce

```

모든 솔루션은 인풋 배열인 nums의 길이와 같다.

매 재귀함수에서 후보를 탐색할 때 nums를 모두 순회해야만 최종적으로 올바른 솔루션에 도달할 수 있다.
이 때 이미 사용한 값은 생략해야만 한다. 불리언 배열 used를 통해 이미 사용한 값을 체크해둘 수 있다.

``` java {1,7,8,10,11}
private void dfs(List<List<Integer>> list, List<Integer> path, int[] nums, boolean[] used) {
    if (path.size() == nums.length) {
        list.add(new ArrayList<>(path));
        return;
    }
    for (int i = 0; i < nums.length; i++) {
        if (used[i]) continue;
        used[i] = true;
        path.add(nums[i]);
        dfs(list, path, nums, used);
        used[i] = false;
        path.remove(path.size() - 1);
    }
}

```

또한 점진적으로 부분 솔루션을 구성하다가 path의 길이가 nums의 길이와 같을때만 결과 배열에 추가할 수 있다.

``` java {2-5}
private void dfs(List<List<Integer>> list, List<Integer> path, int[] nums, boolean[] used) {
    if (path.size() == nums.length) {
        list.add(new ArrayList<>(path));
        return;
    }
    ...생략
}
```

전체 코드는 아래와 같다.

#### 코드
```java
class Solution {
    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> list = new ArrayList<>();
        Arrays.sort(nums);
        dfs(list, new ArrayList<>(), nums, new boolean[nums.length]);
        return list;
    }

    private void dfs(List<List<Integer>> list, List<Integer> path, int[] nums, boolean[] used) {
        if (path.size() == nums.length) {
            list.add(new ArrayList<>(path));
            return;
        }
        for (int i = 0; i < nums.length; i++) {
            if (used[i]) continue;
            used[i] = true;
            path.add(nums[i]);
            dfs(list, path, nums, used);
            used[i] = false;
            path.remove(path.size() - 1);
        }
    }
}

```

### 4. [47. Permutations II](https://leetcode.com/problems/permutations-ii/description/)
중복된 숫자가 포함된 정수 배열의 가능한 모든 순열을 반환한다.

중복된 순열은 아웃풋에 포함될 수 없다.

Input: nums = [1,1,2]
Output: [[1,1,2], [1,2,1], [2,1,1]]

#### 상태공간 트리
``` mermaid
graph TB
    A((empty))-->B((1))
    B-->C((1, 1))
    C-->D((1, 1, 2)):::solution
    B-->E((1, 2)) 
    E-->F((1, 2, 1)):::solution
    A-->G((1)):::endclass
    G-->H((1, 1)):::endclass
    H-->I((1, 1, 2)):::endclass
    G-->J((1, 2)):::endclass
    J-->K((1, 2, 1)):::endclass
    A-->L((2))
    L-->M((2, 1))
    M-->N((2, 1, 1)):::solution
    L-->O((2, 1)):::endclass
    O-->P((2, 1, 1)):::endclass

    classDef solution fill:#d3ffce
    classDef endclass fill:#f6546a

```

permutations의 코드를 그대로 사용하게되면 위 트리와 같은 중복된 솔루션이 포함된다.

후보를 고를 때 nums[i]와 nums[i - 1]을 비교하여 값이 같으면 생략하는 방식으로 중복을 제거할 수 있다.

다만 i - 1이 배열의 범위를 넘어서는 것을 방지하기 위해 i > 0을 추가해야만 한다.

또한 DFS에서 깊은 노드로 탐색된 후 부모 노드로 돌아왔을 경우에만 중복을 제거해야 하기 때문에 used[i - 1]이 false일 경우에만 탐색을 생략해야만 한다.

``` java {5}
private void dfs(List<List<Integer>> list, List<Integer> path, int[] nums, boolean[] used) {
    ...생략
    for (int i = 0; i < nums.length; i++) {
        if(used[i]) continue;
        if(i > 0 && nums[i] == nums[i-1] && !used[i - 1]) continue;
        used[i] = true;
        path.add(nums[i]);
        dfs(list, path, nums, used);
        path.remove(path.size() - 1);
        used[i] = false;
    }
}
```
nums[i]와 nums[i - 1]을 비교할때 배열이 정렬되어 있음을 가정하기 때문에 인풋 배열을 정렬해야만 한다.

``` java {3}
public List<List<Integer>> permute(int[] nums) {
    List<List<Integer>> list = new ArrayList<>();
    Arrays.sort(nums);
    dfs(list, new ArrayList<>(), nums, new boolean[nums.length]);
    return list;
}
```

위와 같은 코드를 추가하고 필요없는 리프노드를 가지치기하면 아래와 같은 상태공간 트리가 생성된다.

``` mermaid
graph TB
    A((empty))-->B((1))
    B-->C((1, 1))
    C-->D((1, 1, 2)):::solution
    B-->E((1, 2)) 
    E-->F((1, 2, 1)):::solution
    A-->L((2))
    L-->M((2, 1))
    M-->N((2, 1, 1)):::solution

    classDef solution fill:#d3ffce

```

#### 전체코드
```java
class Solution {
    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> list = new ArrayList<>();
        Arrays.sort(nums);
        dfs(list, new ArrayList<>(), nums, new boolean[nums.length]);
        return list;
    }

    private void dfs(List<List<Integer>> list, List<Integer> path, int[] nums, boolean[] used) {
        if (path.size() == nums.length) {
            list.add(new ArrayList<>(path));
            return;
        }
        for (int i = 0; i < nums.length; i++) {
            if(used[i]) continue;
            if(i > 0 && nums[i] == nums[i-1] && !used[i - 1]) continue;
            used[i] = true;
            path.add(nums[i]);
            dfs(list, path, nums, used);
            path.remove(path.size() - 1);
            used[i] = false;
        }
    }
}
```
### 5. [39. Combination Sum](https://leetcode.com/problems/combination-sum/description/)
인풋으로 고유한 정수 배열 candidates와 target 정수가 있을 때, 모두 합산하여 target이 되는 모든 정수 집합을 구합니다.

같은 숫자를 여러번 사용할 수 있습니다. 빈도가 같을 경우 같은 집합으로 여깁니다. ([2, 2, 3] [2, 3, 2]는 같다.)

Input: candidates = [2, 3, 6, 7], target = 7

Output: [[2, 2, 3], [7]]

#### 상태공간 트리
``` mermaid

graph TB
    ROOT((empty))-->A((2))

    A-->B((2, 2))
    B-->C((2, 2, 2))
    C-->D((2, 2, 2, 2)):::fail
    C-->F((2, 2, 2, 3)):::fail
    C-->H((2, 2, 2, 6)):::fail
    C-->J((2, 2, 2, 7)):::fail

    B-->L((2, 2, 3)):::solution
    B-->N((2, 2, 6)):::fail
    B-->P((2, 2, 7)):::fail

    A-->S((2, 3))
    S-->U((2, 3, 3)):::fail
    S-->V((2, 3, 6)):::fail
    S-->W((2, 3, 7)):::fail

    A-->X((2, 6)):::fail
    A-->Y((2, 7)):::fail

    ROOT-->AA((3))
    AA-->AB((3, 3))
    AB-->AC((3, 3, 3)):::fail
    AB-->AD((3, 3, 6)):::fail
    AB-->AE((3, 3, 7)):::fail

    AA-->AF((3, 6)):::fail
    AA-->AG((3, 7)):::fail

    ROOT-->AH((6))
    AH-->AI((6, 6)):::fail
    AH-->AJ((6, 7)):::fail

    ROOT-->AK((7)):::solution

    classDef solution fill:#d3ffce
    classDef fail fill:#f6546a
```

탐색할 때 중요한 포인트는 같은 수를 여러 번 사용할 수 있다는 점과 순서에 상관없이 같은 빈도의 요소를 가진 집합은 같은 것으로 간주합니다.

``` java {3}
for (int i = start; i < nums.length; i++) {
    path.add(nums[i]);
    dfs(list, path, nums, remain - nums[i], i);
    path.remove(path.size() - 1);
}
```

for문으로 트리의 하위 노드를 탐색할 때 i를 dfs의 인자로 넘겨주면 하위 노드에서 현재 인덱스부터 탐색하기 때문에 [2, 2, 2, 2]와 같은 중복 값으로 솔루션을 구성할 수 있게 된다.
만약 i + 1로 하게 될 경우 같은 수를 다시는 탐색하지 않는다.

또한 for문의 i 초기화를 start로 하지 않고 0으로 하게되면 매 하위 노드에서 모든 값을 다시 탐색하기 때문에 [2, 2, 3], [2, 3, 2], [3, 2, 2]와 같은 빈도의 중복된 집합을 솔루션에 포함하게 된다. 

솔루션의 제약 조건으로 솔루션 집합의 모든 정수를 합할 경우 target 정수와 같은 값이 되어야만 합니다.
만약 합하였을 때 target보다 클 경우 더 이상 깊게 탐색할 필요가 없습니다.

``` java
if (remain < 0) return;
if (remain == 0) {
    list.add(new ArrayList<>(path));
    return;
}
```

#### 전체코드
```java {10-14, 16, 18}
class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> result = new ArrayList<>();
        dfs(result, new ArrayList<>(), candidates, target, 0);
        return result;
    }

    private void dfs(List<List<Integer>> list, ArrayList<Integer> path,
                    int[] nums, int remain, int start) {
        if (remain < 0) return;
        if (remain == 0) {
            list.add(new ArrayList<>(path));
            return;
        }

        for (int i = start; i < nums.length; i++) {
            path.add(nums[i]);
            dfs(list, path, nums, remain - nums[i], i);
            path.remove(path.size() - 1);
        }
    }
}

```

### 6. [40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/description/)
#### 코드
```java

```
#### 상태공간 트리
``` mermaid

graph TB
    A((1))--1번-->B((2))

```
### 7. [131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/description/)
#### 코드
```java

```
#### 상태공간 트리
``` mermaid

graph TB
    A((1))--1번-->B((2))

```
### 8. [79. Word Search](https://leetcode.com/problems/word-search/description/)
#### 코드
```java

```
#### 상태공간 트리
``` mermaid

graph TB
    A((1))--1번-->B((2))

```
### 9. [17. Letter Combinations of a Phone Number](https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/)
#### 코드
```java

```
#### 상태공간 트리
``` mermaid

graph TB
    A((1))--1번-->B((2))

```
### 10. [51. N-Queens](https://leetcode.com/problems/n-queens/description/)
#### 코드
```java

```
#### 상태공간 트리
``` mermaid

graph TB
    A((1))--1번-->B((2))

```



참고자료
- https://codeiiest-dev.github.io/Algorithms/Backtracking/Pseudocode/Pseudocode.html
- https://www.geeksforgeeks.org/introduction-to-backtracking-data-structure-and-algorithm-tutorials/
- https://leetcode.com/problems/subsets/solutions/27281/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning/
- https://stackoverflow.com/questions/1294720/whats-the-difference-between-backtracking-and-depth-first-search